#include <Arial14.h>
#include <Arial_black_16.h>
#include <Arial_Black_16_ISO_8859_1.h>
#include <DMD.h>
#include <SystemFont5x7.h>

#include <SPI.h>
#include <DMD.h>
#include <TimerOne.h>
#include "Arial_Black_16.h" 

// Konfigurasi Panel P10
#define DISPLAYS_ACROSS 1
#define DISPLAYS_DOWN 1
DMD dmd(DISPLAYS_ACROSS, DISPLAYS_DOWN);

// Variabel Kontrol
String message = "Kami Dari XII rpl stres"; // Teks awal
char charBuf[256]; 
const long interval = 30; // Kecepatan scroll

void ScanDMD() { 
  dmd.scanDisplayBySPI();
}

void setup() {
  // Menggunakan Serial utama (Pin 0 & 1)
  Serial.begin(9600);
  
  // Inisialisasi DMD
  Timer1.initialize(3000); 
  Timer1.attachInterrupt(ScanDMD);
  
  dmd.clearScreen(true);
  dmd.selectFont(Arial_Black_16);
  
  // Debug ke Serial (Akan terlihat jika Arduino tersambung ke laptop)
  Serial.println(F("P10 Bluetooth Hardware Serial Ready"));
}

void loop() {
  // Membaca data dari Bluetooth (Hardware Serial)
  if (Serial.available() > 0) {
    String newData = "";
    unsigned long startTime = millis();
    
    // Membaca data selama 100ms agar pesan tidak terpotong
    while (millis() - startTime < 100) {
      if (Serial.available() > 0) {
        char inChar = (char)Serial.read();
        // Hanya terima karakter yang bisa dibaca (ASCII 32-126)
        if (inChar >= 32 && inChar <= 126) {
          newData += inChar;
        }
        startTime = millis(); // Reset timer setiap ada karakter masuk
      }
    }

    newData.trim(); // Bersihkan karakter enter/spasi sisa
    if (newData.length() > 0) {
      message = newData;
      dmd.clearScreen(true);
      Serial.print(F("Pesan Diterima: "));
      Serial.println(message);
    }
  }

  // Tampilkan teks ke panel
  displayLogic(message);
}

void displayLogic(String txt) {
  int n = txt.length();
  if (n == 0) return;
  
  txt.toCharArray(charBuf, n + 1);
  int panelWidth = 32 * DISPLAYS_ACROSS;

  // Jika teks pendek (1-3 karakter), tampilkan di tengah (Statis)
  if (n <= 3) {
    int estimatedWidth = n * 10; 
    int xPos = (panelWidth - estimatedWidth) / 2;
    if (xPos < 0) xPos = 0;

    dmd.drawString(xPos, 0, charBuf, n, GRAPHICS_NORMAL);
    
    // Jeda sambil tetap mengecek data Serial masuk
    for(int i = 0; i < 20; i++) {
      if (Serial.available() > 0) return;
      delay(10);
    }
  } else {
    // Mode Running Text
    dmd.drawMarquee(charBuf, n, panelWidth, 0);
    long timer = millis();
    boolean finished = false;
    
    while (!finished) {
      if ((long)(millis() - timer) >= interval) {
        finished = dmd.stepMarquee(-1, 0);
        timer = millis();
        
        // Cek interupsi data masuk di sela-sela animasi
        if (Serial.available() > 0) return; 
      }
    }
  }
}